// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cw_ticket.sql

package db

import (
	"context"
)

const checkTicketExists = `-- name: CheckTicketExists :one
SELECT EXISTS (
    SELECT 1
    FROM cw_ticket
    WHERE id = $1
) AS exists
`

func (q *Queries) CheckTicketExists(ctx context.Context, id int) (bool, error) {
	row := q.db.QueryRow(ctx, checkTicketExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const deleteTicket = `-- name: DeleteTicket :exec
DELETE FROM cw_ticket
WHERE id = $1
`

func (q *Queries) DeleteTicket(ctx context.Context, id int) error {
	_, err := q.db.Exec(ctx, deleteTicket, id)
	return err
}

const getTicket = `-- name: GetTicket :one
SELECT id, summary, board_id, owner_id, company_id, contact_id, resources, updated_by, updated_on, added_on FROM cw_ticket
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTicket(ctx context.Context, id int) (*CwTicket, error) {
	row := q.db.QueryRow(ctx, getTicket, id)
	var i CwTicket
	err := row.Scan(
		&i.ID,
		&i.Summary,
		&i.BoardID,
		&i.OwnerID,
		&i.CompanyID,
		&i.ContactID,
		&i.Resources,
		&i.UpdatedBy,
		&i.UpdatedOn,
		&i.AddedOn,
	)
	return &i, err
}

const listTickets = `-- name: ListTickets :many
SELECT id, summary, board_id, owner_id, company_id, contact_id, resources, updated_by, updated_on, added_on FROM cw_ticket
ORDER BY id
`

func (q *Queries) ListTickets(ctx context.Context) ([]*CwTicket, error) {
	rows, err := q.db.Query(ctx, listTickets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*CwTicket
	for rows.Next() {
		var i CwTicket
		if err := rows.Scan(
			&i.ID,
			&i.Summary,
			&i.BoardID,
			&i.OwnerID,
			&i.CompanyID,
			&i.ContactID,
			&i.Resources,
			&i.UpdatedBy,
			&i.UpdatedOn,
			&i.AddedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteTicket = `-- name: SoftDeleteTicket :exec
UPDATE cw_ticket
SET
    deleted = TRUE,
    updated_on = NOW()
WHERE id = $1
`

func (q *Queries) SoftDeleteTicket(ctx context.Context, id int) error {
	_, err := q.db.Exec(ctx, softDeleteTicket, id)
	return err
}

const upsertTicket = `-- name: UpsertTicket :one
INSERT INTO cw_ticket
(id, summary, board_id, owner_id, company_id, contact_id, resources, updated_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (id) DO UPDATE SET
    summary = EXCLUDED.summary,
    board_id = EXCLUDED.board_id,
    owner_id = EXCLUDED.owner_id,
    company_id = EXCLUDED.company_id,
    contact_id = EXCLUDED.contact_id,
    resources = EXCLUDED.resources,
    updated_by = EXCLUDED.updated_by,
    updated_on = NOW()
RETURNING id, summary, board_id, owner_id, company_id, contact_id, resources, updated_by, updated_on, added_on
`

type UpsertTicketParams struct {
	ID        int     `json:"id"`
	Summary   string  `json:"summary"`
	BoardID   int     `json:"board_id"`
	OwnerID   *int    `json:"owner_id"`
	CompanyID int     `json:"company_id"`
	ContactID *int    `json:"contact_id"`
	Resources *string `json:"resources"`
	UpdatedBy *string `json:"updated_by"`
}

func (q *Queries) UpsertTicket(ctx context.Context, arg UpsertTicketParams) (*CwTicket, error) {
	row := q.db.QueryRow(ctx, upsertTicket,
		arg.ID,
		arg.Summary,
		arg.BoardID,
		arg.OwnerID,
		arg.CompanyID,
		arg.ContactID,
		arg.Resources,
		arg.UpdatedBy,
	)
	var i CwTicket
	err := row.Scan(
		&i.ID,
		&i.Summary,
		&i.BoardID,
		&i.OwnerID,
		&i.CompanyID,
		&i.ContactID,
		&i.Resources,
		&i.UpdatedBy,
		&i.UpdatedOn,
		&i.AddedOn,
	)
	return &i, err
}
