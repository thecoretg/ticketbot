// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cw_contact.sql

package db

import (
	"context"
)

const deleteContact = `-- name: DeleteContact :exec
DELETE FROM cw_contact
WHERE id = $1
`

func (q *Queries) DeleteContact(ctx context.Context, id int) error {
	_, err := q.db.Exec(ctx, deleteContact, id)
	return err
}

const getContact = `-- name: GetContact :one
SELECT id, first_name, last_name, company_id, updated_on, added_on, deleted FROM cw_contact
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetContact(ctx context.Context, id int) (*CwContact, error) {
	row := q.db.QueryRow(ctx, getContact, id)
	var i CwContact
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.CompanyID,
		&i.UpdatedOn,
		&i.AddedOn,
		&i.Deleted,
	)
	return &i, err
}

const listContacts = `-- name: ListContacts :many
SELECT id, first_name, last_name, company_id, updated_on, added_on, deleted FROM cw_contact
ORDER BY id
`

func (q *Queries) ListContacts(ctx context.Context) ([]*CwContact, error) {
	rows, err := q.db.Query(ctx, listContacts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*CwContact
	for rows.Next() {
		var i CwContact
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.CompanyID,
			&i.UpdatedOn,
			&i.AddedOn,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteContact = `-- name: SoftDeleteContact :exec
UPDATE cw_contact
SET
    deleted = TRUE,
    updated_on = NOW()
WHERE id = $1
`

func (q *Queries) SoftDeleteContact(ctx context.Context, id int) error {
	_, err := q.db.Exec(ctx, softDeleteContact, id)
	return err
}

const upsertContact = `-- name: UpsertContact :one
INSERT INTO cw_contact
(id, first_name, last_name, company_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id) DO UPDATE SET
    first_name = EXCLUDED.first_name,
    last_name = EXCLUDED.last_name,
    company_id = EXCLUDED.company_id,
    updated_on = NOW()
RETURNING id, first_name, last_name, company_id, updated_on, added_on, deleted
`

type UpsertContactParams struct {
	ID        int     `json:"id"`
	FirstName string  `json:"first_name"`
	LastName  *string `json:"last_name"`
	CompanyID *int    `json:"company_id"`
}

func (q *Queries) UpsertContact(ctx context.Context, arg UpsertContactParams) (*CwContact, error) {
	row := q.db.QueryRow(ctx, upsertContact,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.CompanyID,
	)
	var i CwContact
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.CompanyID,
		&i.UpdatedOn,
		&i.AddedOn,
		&i.Deleted,
	)
	return &i, err
}
