// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: totp_pending.sql

package db

import (
	"context"
	"time"
)

const createTOTPPending = `-- name: CreateTOTPPending :one
INSERT INTO totp_pending (user_id, token_hash, expires_at)
VALUES ($1, $2, $3)
RETURNING id, user_id, token_hash, expires_at, created_on
`

type CreateTOTPPendingParams struct {
	UserID    int       `json:"user_id"`
	TokenHash []byte    `json:"token_hash"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreateTOTPPending(ctx context.Context, arg CreateTOTPPendingParams) (*TotpPending, error) {
	row := q.db.QueryRow(ctx, createTOTPPending, arg.UserID, arg.TokenHash, arg.ExpiresAt)
	var i TotpPending
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.CreatedOn,
	)
	return &i, err
}

const deleteExpiredTOTPPendings = `-- name: DeleteExpiredTOTPPendings :exec
DELETE FROM totp_pending WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredTOTPPendings(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredTOTPPendings)
	return err
}

const deleteTOTPPending = `-- name: DeleteTOTPPending :exec
DELETE FROM totp_pending WHERE id = $1
`

func (q *Queries) DeleteTOTPPending(ctx context.Context, id int) error {
	_, err := q.db.Exec(ctx, deleteTOTPPending, id)
	return err
}

const getTOTPPendingByTokenHash = `-- name: GetTOTPPendingByTokenHash :one
SELECT id, user_id, token_hash, expires_at, created_on FROM totp_pending
WHERE token_hash = $1 AND expires_at > NOW()
LIMIT 1
`

func (q *Queries) GetTOTPPendingByTokenHash(ctx context.Context, tokenHash []byte) (*TotpPending, error) {
	row := q.db.QueryRow(ctx, getTOTPPendingByTokenHash, tokenHash)
	var i TotpPending
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.CreatedOn,
	)
	return &i, err
}
